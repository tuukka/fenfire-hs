module VobTest where

-- Copyright (c) 2006-2007, Benja Fallenstein, Tuukka Hastrup
-- This file is part of Fenfire.
-- 
-- Fenfire is free software; you can redistribute it and/or modify it under
-- the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 2 of the License, or
-- (at your option) any later version.
-- 
-- Fenfire is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
-- Public License for more details.
-- 
-- You should have received a copy of the GNU General
-- Public License along with Fenfire; if not, write to the Free
-- Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-- MA  02111-1307  USA

import Utils
import Cairo
import Vobs
import Data.Map (fromList)
import Data.IORef
import Data.Monoid hiding (Endo)
import Control.Applicative
import Control.Monad.State
import Graphics.UI.Gtk hiding (Point, Size, Layout, Color, get, fill)


--myVob1 :: Vob Int
--myVob1 = keyVob 1 $ rectBox $ pad 5 $ multiline False 20 "Hello World!"

myVob2 :: Vob Int
myVob2 = keyVob 2 $ rectBox $ label "Foo bar baz"

myScene1 :: Vob Int
myScene1 = mconcat [ stroke $ line (center @@ 1) (center @@ 2),
                     translate #50 #100 $ myVob2,
                     translate #250 #150  $ myVob1 ]

myScene2 :: Vob Int
myScene2 = translate #150 #150 $ rotate #(-pi/15) $ scale #1.5 $ 
    changeSize (\(w,h) -> (w-30, h)) $ myVob1


myVob1 :: Vob Int
myVob1 = keyVob 1 $ resize (100, 100) $ daisy "A" [
        ("B", 20, 24), ("C", 12, 30), ("X", 14, 19)
    ]


daisy :: Ord k => String -> [(String, Double, Double)] -> Vob k
daisy target distractors = 
      stroke (circle (point 0 0) inner)
    & stroke (circle (point 0 0) (inner + w / 4))
    & stroke (circle (point 0 0) (inner + 9*w / 16))
    & stroke (circle (point 0 0) (inner + w))
    & mconcat [rotate #(((fromIntegral i)::Double) * angle) $ 
               translate #inner #0 $ daisyLeaf w (distractors !! i) 
              | i <- [0..n-1]]
    & centerVob (label target)
  where
    w = 100.0 :: Double; inner = 20.0 :: Double
    n = length distractors
    angle :: Double
    angle = (2.0*pi) / fromIntegral n


daisyLeaf :: Ord k => Double -> (String, Double, Double) -> Vob k
daisyLeaf w (name, correct, total) =
    withColor #color (fill shape) & stroke shape
    & translate #(w*(correct/total)**2) #0 (centerVob $ label name)
  where
    shape = moveTo (head $ points 1) & mconcat (map lineTo $ tail $ points 1) &
            mconcat (map lineTo $ reverse $ points (-1)) & closePath
    points dir = [point (w*(p**2)) (w*dir*arbitrary*y) 
                 | (p,y) <- zip ps (map (/ sum ys) ys)]
        where ps = map (/100.0) [0..100]; ys = map f ps
    f p = (p ** correct) * ((1 - p) ** (total - correct))
    arbitrary = 4
    color = interpolate (correct/total) (Color 1 0 0 1) (Color 0 1 0 1)

main = do 
    initGUI
    window <- windowNew
    windowSetTitle window "Vob test"
    windowSetDefaultSize window 700 400

    stateRef <- newIORef False

    let view state    = if state then myScene1 else myScene2
        handle _event = do modify not; setInterp True

    (canvas, _updateCanvas) <- vobCanvas stateRef view handle 
                                         (const $ return ()) lightGray

    set window [ containerChild := canvas ]
    
    onDestroy window mainQuit
    widgetShowAll window
    mainGUI
