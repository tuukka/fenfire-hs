module VobTest where

-- Copyright (c) 2006-2007, Benja Fallenstein, Tuukka Hastrup
-- This file is part of Fenfire.
-- 
-- Fenfire is free software; you can redistribute it and/or modify it under
-- the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 2 of the License, or
-- (at your option) any later version.
-- 
-- Fenfire is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
-- Public License for more details.
-- 
-- You should have received a copy of the GNU General
-- Public License along with Fenfire; if not, write to the Free
-- Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-- MA  02111-1307  USA

import Utils
import Cairo
import Vobs
import qualified Data.List
import Data.Map (fromList)
import Data.Maybe (fromJust)
import Data.IORef
import Data.Monoid hiding (Endo)
import Control.Applicative
import Control.Monad.State
import Graphics.UI.Gtk hiding (Point, Size, Layout, Color, get, fill)


type Info = (String, Double, Double)
type Data = [(String,[Info])]

--myVob1 :: Vob String
--myVob1 = keyVob "1" $ rectBox $ pad 5 $ multiline False 20 "Hello World!"

myVob2 :: Vob String
myVob2 = mempty --keyVob "2" $ rectBox $ label "Foo bar baz"

myScene1 :: String -> Data -> Vob String
myScene1 t d = mconcat [ stroke $ line (center @@ "1") (center @@ "2"),
                         translate #50 #100 $ myVob2,
                         translate #250 #150  $ myVob1 t d ]

myScene2 :: String -> Data -> Vob String
myScene2 t d = translate #350 #400 $ rotate #(-pi/15) $ scale #1.5 $ 
    changeSize (\(w,h) -> (w-30, h)) $ myVob1 t d
    
    
myVob1 :: String -> Data -> Vob String
myVob1 t d = keyVob "1" $ {-ownSize $ resize (250, 250) $-} 
        pad 20 $ daisy t info where
    info = fromJust (Data.List.lookup t d)


daisy :: String -> [(String, Double, Double)] -> Vob String
daisy target distractors = 
      mconcat [withDash #[4] #0 $
                   stroke (circle center #(inner + !w * radius))
              | radius <- [0, 1/4, 9/16, 1]]
    & mconcat [(translateTo center $
                   rotate #(((fromIntegral i)::Double) * angle) $
                       translate #inner #0 $ daisyLeaf w (distractors !! i))
               & translateTo (center @@ name i) (centerVob $ label $ name i)
              | i <- [0..n-1]]
    & translateTo center (centerVob $ label target)
  where
    inner = 20.0 :: Double
    size = #(uncurry min !cxSize); w = #((!size - inner)/2)
    n = length distractors
    name i = case distractors !! i of (r,_,_) -> r
    angle :: Double
    angle = (2.0*pi) / fromIntegral n


daisyLeaf :: Cx String Double -> (String, Double, Double) -> Vob String
daisyLeaf w (name, correct, total) =
    withColor #color (fill shape) & stroke shape
    & translate #(!w*(correct/total)**2) #0 (ownSize $ keyVob name mempty)
  where
    shape = moveTo (head $ points 1) & mconcat (map lineTo $ tail $ points 1) &
            mconcat (map lineTo $ reverse $ points (-1)) & closePath
    points dir = [point #(!w*(p**2)) #(!w*dir*arbitrary*y) 
                 | (p,y) <- zip ps (map (/ sum ys) ys)]
        where ps = map (/100.0) [0..100]; ys = map f ps
    f p = (p ** correct) * ((1 - p) ** (total - correct))
    arbitrary = 4
    color = interpolate (correct/total) (Color 1 0 0 0.5) (Color 0 1 0 0.5)

main = do 
    testdata <- readFile "DaisyData.txt" >>= return . (read :: String -> Data)

    initGUI
    window <- windowNew
    windowSetTitle window "Vob test"
    windowSetDefaultSize window 700 400

    stateRef <- newIORef (fst $ head testdata)

    let view state    = myVob1 state testdata
        handle _event = do t <- get; let ts = map fst testdata
                           let i = fromJust $ Data.List.elemIndex t ts
                               i' = if i+1 >= length ts then 0 else i+1
                           put (ts !! i')
                           setInterp True

    (canvas, _updateCanvas, _canvasEvent) <- vobCanvas stateRef view handle 
                                                       (const $ return ()) 
                                                       lightGray

    set window [ containerChild := canvas ]
    
    onDestroy window mainQuit
    widgetShowAll window
    mainGUI
