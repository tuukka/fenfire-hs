{-# OPTIONS_GHC -fallow-overlapping-instances -fimplicit-params #-}
module Fenfire where

-- Copyright (c) 2006-2007, Benja Fallenstein, Tuukka Hastrup
-- This file is part of Fenfire.
-- 
-- Fenfire is free software; you can redistribute it and/or modify it under
-- the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 2 of the License, or
-- (at your option) any later version.
-- 
-- Fenfire is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
-- Public License for more details.
-- 
-- You should have received a copy of the GNU General
-- Public License along with Fenfire; if not, write to the Free
-- Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-- MA  02111-1307  USA

import qualified Cache
import Cairo hiding (rotate, Path)
import Vobs
import Utils
import RDF

import Paths_fenfire (getDataFileName)

import qualified Raptor (filenameToTriples, uriToTriples,
                         triplesToFilename, Identifier(..))

import qualified Data.Map as Map
import qualified Data.Set as Set
import qualified Data.Tree as Tree
import Data.List (intersperse)
import qualified Data.List
import Data.Set (Set)
import Data.IORef
import Data.Maybe (fromMaybe, fromJust, isJust, isNothing, catMaybes)
import Data.Monoid(Monoid(mempty, mconcat), Dual(Dual), getDual)

import Control.Applicative
import Control.Monad (when, guard, mplus, msum, liftM, join)
import Control.Monad.Reader (ReaderT, runReaderT, local, ask, asks)
import Control.Monad.State (StateT, get, gets, modify, put, execStateT)
import Control.Monad.Trans (lift, liftIO)
import Control.Monad.Writer (Writer, execWriter, tell)

import GtkFixes
import Graphics.UI.Gtk hiding (Color, get, disconnect, fill,
-- GtkFixes overrides:
                               actionNew,
                               widgetGetStyle,
                               styleGetForeground, styleGetBackground, 
                               styleGetLight, styleGetMiddle, styleGetDark,
                               styleGetText, styleGetBase, 
                               styleGetAntiAliasing)

import qualified Control.Exception
import System.Directory (canonicalizePath)
import System.Environment (getArgs, getProgName)
import System.Mem.StableName
import System.Random (randomRIO)

data ViewSettings = ViewSettings { hiddenProps :: [Node], maxCenter :: Int }
data FenState = FenState {
    fsGraph :: Graph, fsRotation :: Rotation, fsMark :: Mark,
    fsFilePath :: FilePath, fsGraphModified :: Bool, fsHasFocus :: Bool,
    fsView :: Int, fsProperty :: Node, fsProperties :: Set Node,
    fsUndo :: [(Graph,Rotation)], fsRedo :: [(Graph,Rotation)]}
    
fsNode :: FenState -> Node
fsNode (FenState { fsRotation = Rotation node _ }) = node
                           
type Views = [(String, View FenState Node)]

data Rotation = Rotation Node Int         deriving (Eq, Show)

fromPath :: (?vs :: ViewSettings, ?graph :: Graph) => Path -> Maybe Rotation
fromPath path@(Path node (Conn _ dir _ : _)) = do
    let c = conns node dir
    i <- Data.List.elemIndex path c
    return $ Rotation node (i - min (length c `div` 2) (maxCenter ?vs))
fromPath (Path node []) = Just $ Rotation node 0
                     
toPath :: (?vs :: ViewSettings, ?graph :: Graph) =>
          Rotation -> Dir -> Maybe Path
toPath (Rotation node r) dir = let c = conns node dir in
    c !? (min (length c `div` 2) (maxCenter ?vs) + r)
    
connsCache :: Cache.Cache (StableName Graph, (Node, Dir)) [Path]
connsCache = Cache.newCache 10000

dc_date = URI "dc:date"

conns :: (?vs :: ViewSettings, ?graph :: Graph) => Node -> Dir -> [Path]
conns node dir = Cache.cached (Cache.byAddress ?graph, (node,dir))
                              connsCache result where
    result = map (\(prop, node') -> Path node [Conn prop dir node']) sorted
    sorted = Data.List.sortBy cmp' list
    list = [(p,n) | (p,s) <- Map.toList $ getConns ?graph node dir,
                    not (p `elem` hiddenProps ?vs), n <- Set.toList s]
    cmp n1 n2 | p n1 && p n2 = compare (f n1) (f n2) where
        p n = hasConn ?graph n dc_date Pos; f n = getOne ?graph n dc_date Pos
    cmp n1 n2 = compare (getText n1) (getText n2)
    cmp' (p1,n1) (p2,n2) = catOrds (cmp p1 p2) (cmp n1 n2)
    catOrds EQ o = o; catOrds o _ = o

rotate :: (?vs :: ViewSettings, ?graph :: Graph) =>
          Rotation -> Int -> Maybe Rotation
rotate (Rotation n r) dir = let rot = Rotation n (r+dir) in do
    guard $ any isJust [toPath rot d | d <- [Pos, Neg]]; return rot

move :: (?vs :: ViewSettings, ?graph :: Graph) =>
        Rotation -> Dir -> Maybe Rotation
move rot dir = do path <- toPath rot dir
                  fromPath (rev path)

getText :: (?graph :: Graph) => Node -> Maybe String
getText n = fmap f $ getOne ?graph n rdfs_label Pos where 
    f (PlainLiteral s) = s; f _ = error "getText argh"
    
getTextOrURI :: (?graph :: Graph) => Node -> String
getTextOrURI n = fromMaybe (showNode (graphNamespaces ?graph) n) (getText n)
                    
setText :: Node -> String -> Endo Graph
setText n t = update (n, rdfs_label, PlainLiteral t)

nodeView :: (?graph :: Graph) => Node -> Vob Node
nodeView n = useFgColor $ multiline False 20 $ getTextOrURI n
    
propView :: (?graph :: Graph) => Node -> Vob Node
propView n = (useFadeColor $ fill extents)
           & (pad 5 $ useFgColor $ label $ getTextOrURI n)



vanishingView :: (?vs :: ViewSettings) => Int -> Int -> Color -> Color -> 
                                          Color -> Color -> 
                                          Color -> Color -> FenState -> Vob Node
vanishingView depth maxnodes bgColor blurBgColor focusColor blurColor 
              textColor blurTextColor
              (FenState {fsRotation=startRotation, fsGraph=graph, fsMark=mark,
                         fsHasFocus=focus, fsProperty=property}) =
    let ?graph = graph in result where
    result :: (?graph :: Graph) => Vob Node
    result = currentProp & runVanishing depth maxnodes view where
    currentProp = ownSize $ rectBox $ pad 5 $ nodeView property
    -- place the center of the view and all subtrees in both directions
    view = do placeNode (if focus then Just (bgColor, focusColor, textColor) 
                             else Just (blurBgColor, blurColor, blurTextColor))
                  startRotation
              let Rotation n _ = startRotation in visitNode n
              forM_ [Pos, Neg] $ \dir -> do
                  placeConns startRotation dir True
    -- place all subtrees in xdir
    placeConns rotation xdir placeFirst = withDepthIncreased 1 $ do
        when placeFirst $ placeConn rotation xdir
        forM_ [-1, 1] $ \ydir -> do
            placeConns' rotation xdir ydir
    -- place rest of the subtrees in (xdir, ydir)
    placeConns' rotation xdir ydir = withDepthIncreased 1 $
        maybeDo (rotate rotation ydir) $ \rotation' -> do
            withAngleChanged (fromIntegral ydir * mul xdir pi / 14) $ do
                placeConn rotation' xdir
                placeConns' rotation' xdir ydir
    -- place one subtree
    placeConn rotation@(Rotation n1 _) dir = withDepthIncreased 1 $
        maybeDo (toPath rotation dir) $ \path@(Path _ [Conn prop _ n2]) -> do
            let rotation' = fromJust $ fromPath (rev path)
            scale' <- getScale
            withCenterMoved dir (280 * (scale'**3)) $ do
                ifUnvisited n2 $ placeNode Nothing rotation'
                let (nl,nr) = if dir==Pos then (n1,n2) else (n2,n1)
                addVob $ between (center @@ nl) (center @@ nr) $ ownSize $
                    centerVob $ scale #scale' $ propView prop
                addVob $ useFgColor $ stroke $
                    line (center @@ nl) (center @@ nr)
                ifUnvisited n2 $ visitNode n2 >> do
                    placeConns rotation' dir True
                    withDepthIncreased 3 $
                        placeConns rotation' (rev dir) False
    -- place one node view
    placeNode cols (Rotation node _) = do
        scale' <- getScale
        let f vob = case bg of Nothing -> vob
                               Just c  -> setFgColor fg $ 
                                          setBgColor c vob
            markColor = if node `Set.member` mark then Just (Color 1 0 0 1)
                            else Nothing
            bg = combine (fmap (\(_,b,_) -> b) cols) markColor
            fg = maybe (Color 0 0 0 1) (\(_,_,c) -> c) cols
            combine Nothing c = c
            combine c Nothing = c
            combine (Just c1) (Just c2) = Just $ interpolate 0.5 c1 c2
            g vob = case cols of Nothing    -> vob
                                 Just (a,_,_) -> frame a & vob
                where (w,h) = defaultSize vob
                      frame c = withColor #c $ fill $ 
                                    moveTo (point #(0-10) #(0-10)) &
                                    lineTo (point #(w+10) #(0-10)) &
                                    lineTo (point #(w+10) #(h+10)) &
                                    lineTo (point #(0-10) #(h+10)) &
                                    closePath
        placeVob $ ownSize $ scale #scale' $ keyVob node $ g $ 
            f (useBgColor (fill extents) & pad 5 (nodeView node)) &
            useFgColor (stroke extents)
        
    getScale :: VV Double
    getScale = do d <- asks vvDepth; return (0.97 ** fromIntegral d)
    
    
data VVState = VVState { vvDepth :: Int, vvMaxDepth :: Int, vvMaxNodes :: Int,
                         vvX :: Double, vvY :: Double, vvAngle :: Double }
                         
type VV a = ReaderT VVState (BreadthT (StateT (Set Node) 
                                          (Writer (Dual (Vob Node))))) a

runVanishing :: Int -> Int -> VV () -> Vob Node
runVanishing maxdepth maxnodes vv = comb (0,0) $ \cx -> 
    let (w,h) = rcSize cx 
    in getDual $ execWriter $ flip execStateT Set.empty $ execBreadthT $
           runReaderT vv $ VVState 0 maxdepth maxnodes (w/2) (h/2) 0
    
-- |Execute the passed action with the recursion depth increased by
-- the given amount of steps, if it is still smaller than the maximum
-- recursion depth.
--
withDepthIncreased :: Int -> VV () -> VV ()
withDepthIncreased n m = do
    state <- ask; let state' = state { vvDepth = vvDepth state + n }
    if vvDepth state' >= vvMaxDepth state' then return () else
        lift $ scheduleBreadthT $ flip runReaderT state' $ do
            visited <- get
            when (Set.size visited <= (4 * vvMaxNodes state') `div` 3) m
        
visitNode :: Node -> VV ()
visitNode n = modify (Set.insert n)

ifUnvisited :: Node -> VV () -> VV ()
ifUnvisited n m = do visited <- get
                     when (not $ n `Set.member` visited) m

addVob :: Vob Node -> VV ()
addVob vob = do d <- asks vvDepth; md <- asks vvMaxDepth
                mn <- asks vvMaxNodes; visited <- get
                let x = (fromIntegral (md - d) / fromIntegral (md+2))
                    vob' = if Set.size visited >= mn then invisibleVob vob
                                                     else fade x vob
                tell (Dual vob')

placeVob :: Vob Node -> VV ()
placeVob vob = do
    state <- ask
    addVob $ translate #(vvX state) #(vvY state) $ centerVob vob
        
withCenterMoved :: Dir -> Double -> VV () -> VV ()
withCenterMoved dir distance = local f where
    distance' = mul dir distance
    f s = s { vvX = vvX s + distance' * cos (vvAngle s),
              vvY = vvY s + distance' * sin (vvAngle s) }
                   
withAngleChanged :: Double -> VV () -> VV ()
withAngleChanged delta = local $ \s -> s { vvAngle = vvAngle s + delta }



presentationView :: (?vs :: ViewSettings) => View FenState Node
presentationView state = let ?graph = fsGraph state in result where
    result :: (?graph :: Graph) => Vob Node
    result = cursor & vob where
    Rotation node _ = fsRotation state
    children = map getPos (conns node Pos)
    selected = fmap (getSide Pos) (toPath (fsRotation state) Pos)
    f sc n = keyVob n $ useFgColor $ pad 5 $ scaleVob sc $
                 multiline True 70 $ getTextOrURI n
    cursor = flip (maybe mempty) selected $ \n -> 
                 showAtKey n $ keyVob (PlainLiteral "CURSOR") $ rectBox mempty
    space = changeSize (const (0, 20)) mempty
    vob = pad 30 $ vbox $ intersperse space $ f 3 node : map (f 2) children



tryMove :: (?vs :: ViewSettings, ?graph :: Graph) =>
           Rotation -> Dir -> Maybe Rotation
tryMove rot@(Rotation n r) dir = maybe rot' Just (move rot dir) where
    rot' | r == nearest = Nothing
         | otherwise    = Just $ Rotation n nearest
    nearest | r > 0     = len-1 - min (len `div` 2) (maxCenter ?vs)
            | otherwise = 0 - min (len `div` 2) (maxCenter ?vs)
    len = (length $ conns n dir)

type URIMaker = (String, IORef Integer)

newURIMaker :: IO URIMaker
newURIMaker = do rand <- sequence [randomRIO (0,63) | _ <- [1..27::Int]]
                 let chars = ['a'..'z'] ++ ['A'..'Z'] ++ ['0'..'9'] ++ "+-"
                 ref <- newIORef 1
                 return ("urn:urn-5:" ++ map (chars !!) rand, ref)

newURI :: (?uriMaker :: URIMaker) => IO Node
newURI = do let (base, ref) = ?uriMaker
            i <- readIORef ref; writeIORef ref (i+1)
            return $ URI (base ++ ":_" ++ show i)

newNode :: (?vs :: ViewSettings, ?uriMaker :: URIMaker) => 
           Dir -> Node -> EndoM IO (Graph, Rotation)
newNode dir prop (graph, Rotation node _) = do
    node' <- newURI
    let ?graph = insert (triple dir (node, prop, node'))
               $ insert (node', rdfs_label, PlainLiteral "") graph
     in return (?graph, fromJust $ fromPath (Path node' [Conn prop (rev dir) node]))
    
connect :: (?vs :: ViewSettings) => Dir -> Endo FenState
connect _ state | Set.null (fsMark state) = state
connect dir state@(FenState { fsRotation=Rotation node _ }) =
    let nodes = Set.toList (fsMark state); prop = fsProperty state in
    let ?graph = foldr (\n -> insert $ triple dir (node, prop, n))
                       (fsGraph state) nodes in
    state { fsRotation = fromJust $ fromPath (Path node [Conn prop dir (head nodes)]),
            fsGraph = ?graph, fsMark = Set.empty, fsGraphModified = True,
            fsUndo = (fsGraph state,fsRotation state):fsUndo state,
            fsRedo = [] }

disconnect :: (?vs :: ViewSettings) => Dir -> Endo FenState
disconnect dir state@(FenState { fsRotation=rot@(Rotation node _) }) =
    let ?graph = fsGraph state in 
    case toPath rot dir of
        Nothing -> state
        Just path -> 
            let path' = msum [flip toPath xdir =<< rotate rot ydir |
                              xdir <- [Neg,Pos], ydir <- [-1,1]]
                triples = pathToTriples path
                graph' = foldr delete (fsGraph state) triples
                rot' = fromMaybe (Rotation node 0) $
                       let ?graph = graph' in fromPath =<< path'
             in state { fsGraph=graph', fsRotation=rot', fsGraphModified=True,
                        fsUndo=(fsGraph state,fsRotation state):fsUndo state, fsRedo=[]}


type Mark = Set Node

toggleMark :: Node -> Endo Mark
toggleMark n mark | n `Set.member` mark = Set.delete n mark
                  | otherwise           = Set.insert n mark

newGraph :: (?uriMaker :: URIMaker) => IO (Graph, Rotation)
newGraph = do
    home <- newURI
    let graph = listToGraph [(home, rdfs_label, PlainLiteral "")]
    return (graph, Rotation home 0)
    
findStartRotation :: (?vs :: ViewSettings) => Graph -> Rotation
findStartRotation g = let ?graph = g in result where
    result :: (?graph :: Graph) => Rotation
    result = head $ catMaybes $ startNode:topic:triples where
    self = URI "ex:graph" -- ought to be what the empty URI <> is expanded to

    startNode = getRot =<< getTriple self ffv_startNode
    topic = getRot =<< getTriple self foaf_primaryTopic
    triples = map getRot $ graphToList g
    
    getTriple s p = fmap (\o -> (s,p,o)) $ getOne g s p Pos
    getRot (s,p,o) = fromPath (Path o [Conn p Neg s])
    
    ffv_startNode = URI "http://fenfire.org/rdf-v/2003/05/ff#startNode"
    foaf_primaryTopic = URI "http://xmlns.com/foaf/0.1/primaryTopic"

loadGraph :: FilePath -> IO Graph
loadGraph fileName = do
    --file <- readFile fileName
    --graph <- fromNTriples file >>= return . reverse-}
    let convert (s,p,o) = (f s, f p, f o)
        f (Raptor.Uri s) = URI s
        f (Raptor.Literal s) = PlainLiteral s
        f (Raptor.Blank s) = URI $ "blank:" ++ s
    (raptorTriples, namespaces) <- if Data.List.isPrefixOf "http:" fileName
        then Raptor.uriToTriples fileName Nothing
        else Raptor.filenameToTriples fileName (Just "fakebase:/")
    triples <- return $ map convert raptorTriples
    return $ foldr (uncurry addNamespace) (listToGraph triples) namespaces

saveGraph :: Graph -> FilePath -> IO ()
saveGraph graph fileName = do
    --writeFile fileName $ toNTriples $ reverse graph
    let convert (s,p,o) = (f s, f p, f o)
        f (URI s) = Raptor.Uri s
        f (PlainLiteral s) = Raptor.Literal s
        triples = graphToList graph
        namespaces = Map.toAscList $ graphNamespaces graph
    Raptor.triplesToFilename (map convert triples) namespaces fileName
    putStrLn $ "Saved: " ++ fileName

openFile :: (?vs :: ViewSettings) => FilePath -> 
            IO (Maybe (Graph, FilePath))
openFile fileName0 = do
    dialog <- fileChooserDialogNew Nothing Nothing FileChooserActionOpen
                                   [(stockCancel, ResponseCancel),
                                    (stockOpen, ResponseAccept)]
    when (fileName0 /= "") $ do fileChooserSetFilename dialog fileName0
                                return ()
    response <- dialogRun dialog
    widgetHide dialog
    case response of
        ResponseAccept -> do Just fileName <- fileChooserGetFilename dialog
                             graph <- loadGraph fileName
                             return $ Just (graph, fileName)
        _              -> return Nothing
        
saveFile :: Graph -> FilePath -> Bool -> IO (FilePath,Bool)
saveFile graph fileName0 confirmSame = do
    dialog <- fileChooserDialogNew Nothing Nothing FileChooserActionSave
                                   [(stockCancel, ResponseCancel),
                                    (stockSave, ResponseAccept)]
    fileChooserSetDoOverwriteConfirmation dialog True
    dialogSetDefaultResponse dialog ResponseAccept
    when (fileName0 /= "") $ do fileChooserSetFilename dialog fileName0
                                return ()
    onConfirmOverwrite dialog $ do 
        Just fileName <- fileChooserGetFilename dialog
        if fileName == fileName0 && not confirmSame
            then return FileChooserConfirmationAcceptFilename
            else return FileChooserConfirmationConfirm
    response <- dialogRun dialog
    widgetHide dialog
    case response of
        ResponseAccept -> do Just fileName <- fileChooserGetFilename dialog
                             let fileName' = checkSuffix fileName
                             saveGraph graph fileName'
                             return (fileName', True)
        _              -> return (fileName0, False)
        
checkSuffix :: FilePath -> FilePath
checkSuffix s | Data.List.isSuffixOf ".turtle" s = s
              | otherwise                        = s ++ ".turtle"

confirmSave :: (?vs :: ViewSettings, ?pw :: Window,
                ?views :: Views, ?uriMaker :: URIMaker) => 
               Bool -> HandlerAction FenState -> 
               HandlerAction FenState
confirmSave False action = action
confirmSave True action = do
    response <- liftIO $ do
        dialog <- makeConfirmUnsavedDialog
        response' <- dialogRun dialog
        widgetHide dialog
        return response'
    case response of ResponseClose  -> action
                     ResponseAccept -> do 
                         handleAction "save"
                         saved <- get >>= return . not . fsGraphModified
                         when (saved) action
                     _              -> return ()

confirmRevert :: (?vs :: ViewSettings, ?pw :: Window) => 
               Bool -> HandlerAction FenState -> 
               HandlerAction FenState
confirmRevert False action = action
confirmRevert True  action = do
    response <- liftIO $ do
        dialog <- makeConfirmRevertDialog
        response' <- dialogRun dialog
        widgetHide dialog
        return response'
    case response of ResponseClose  -> action
                     _              -> return ()

confirmString :: (?vs :: ViewSettings, ?pw :: Window) => 
               String -> String -> (String -> HandlerAction FenState) -> 
               HandlerAction FenState
confirmString title preset action = do
    (response,text) <- liftIO $ do 
        dialog <- makeDialog title
            [(stockCancel, ResponseCancel),
             (stockApply, ResponseAccept)]
            ResponseAccept
        entry <- entryNew
        set entry [ entryText := preset, entryActivatesDefault := True ]
        widgetShow entry
        vBox <- dialogGetUpper dialog
        boxPackStart vBox entry PackNatural 0
        response' <- dialogRun dialog
        text' <- entryGetText entry
        widgetHide dialog
        return (response',text')
    case response of ResponseAccept -> action text
                     _              -> return ()

newState :: Graph -> Rotation -> FilePath -> Bool -> FenState
newState graph rot fp focus = 
    FenState graph rot Set.empty fp False focus 0 rdfs_seeAlso ps [] []
    where ps = Set.insert rdfs_seeAlso $ Set.fromList $
                   map predicate $ filter f $ graphToList graph
          f (_, _, URI _) = True
          f _             = False

stateReplaceNode :: Node -> Node -> Endo FenState
stateReplaceNode m n s@(FenState { fsRotation = Rotation node r }) = FenState {
    fsGraph = replaceNode m n (fsGraph s),
    fsRotation = Rotation (f node) r,
    fsMark = if m `Set.member` fsMark s
             then Set.insert n $ Set.delete m $ fsMark s else fsMark s,
    fsProperty = f (fsProperty s), fsProperties = Set.map f (fsProperties s),
    fsGraphModified = True,
    fsFilePath = fsFilePath s, fsHasFocus = fsHasFocus s, fsView = fsView s,
    fsUndo = (fsGraph s, fsRotation s) : fsUndo s, fsRedo = []
    } where f x = if x == m then n else x

handleEvent :: (?vs :: ViewSettings, ?pw :: Window, ?views :: Views,
                ?uriMaker :: URIMaker) => Handler Event FenState
handleEvent (Key { eventModifier=_mods, eventKeyName=key }) = do
    state <- get; let graph = fsGraph state; fileName = fsFilePath state
    case key of 
        x | x == "Up"    || x == "i"     -> handleAction "up"
        x | x == "Down"  || x == "comma" -> handleAction "down"
        x | x == "Left"  || x == "j"     -> handleAction "left"
        x | x == "Right" || x == "l"     -> handleAction "right"
        "v" -> handleAction "chgview"
        "p" -> handleAction "resetprop"
        "O" -> handleAction "open"
        "S" -> do (fp',saved) <- liftIO $ saveFile graph fileName False
                  let modified' = fsGraphModified state && not saved
                  put $ state { fsFilePath = fp', fsGraphModified = modified' }
        _   -> unhandledEvent
handleEvent _ = unhandledEvent

handleAction :: (?vs :: ViewSettings, ?pw :: Window, ?views :: Views,
                 ?uriMaker :: URIMaker) => Handler String FenState
handleAction action = do
    state@(FenState { fsRotation = rot@(Rotation node r),
                      fsGraph = graph, fsMark = mark, 
                      fsFilePath = filepath, fsGraphModified = modified,
                      fsHasFocus=focus, fsProperty=prop
                    }) <- get
    let ?graph = graph in do
    let b f x = maybeDo (f rot x) $ \rot' -> do 
                    putRotation rot'
                    modify $ \s -> s { fsGraphModified = modified }
        n f x = do (graph', rot') <- liftIO (f x prop (graph, rot))
                   putGraph graph'; putRotation rot'
        o f x = do put (f x state); setInterp True
    case action of
        "up"    -> b rotate (-1)    ; "down"  -> b rotate 1
        "left"  -> b tryMove Neg    ; "right" -> b tryMove Pos
        "nodel" -> n newNode Neg    ; "noder" -> n newNode Pos
        "connl" -> o connect Neg    ; "connr" -> o connect Pos
        "breakl"-> o disconnect Neg ; "breakr"-> o disconnect Pos
        "rmlit" -> putGraph (delLit node graph)
        "mark"  -> putMark $ toggleMark node mark
        "new"   -> confirmSave modified $ do
            (g', rot') <- liftIO newGraph
            put $ newState g' rot' "" focus
        "open"  -> confirmSave modified $ do 
            result <- liftIO $ openFile filepath
            maybeDo result $ \(g',fp') ->
                put $ newState g' (findStartRotation g') fp' focus
        "loadURI" -> case node of 
                         URI uri -> do 
                             g <- liftIO $ loadGraph uri
                             let g' = mergeGraphs graph g
                                 r' = Rotation node r
                                 s' = state {fsGraph=g', fsRotation=r',
                                             fsUndo=(graph,rot):fsUndo state,
                                             fsRedo=[]}
                             put s'
                         _ -> unhandledEvent
        "revert" | filepath /= "" -> confirmRevert modified $ do
            g' <- liftIO $ loadGraph filepath
            put $ newState g' (findStartRotation g') filepath focus
        "save" | filepath /= "" -> do 
                     liftIO $ saveGraph graph filepath
                     modify $ \s -> s { fsGraphModified = False }
               | otherwise      -> handleAction "saveas"
        "saveas"-> do
            (fp',saved) <- liftIO $ saveFile graph filepath True
            let modified' = modified && not saved
            modify $ \s -> s { fsFilePath = fp', fsGraphModified = modified' }
        "quit"  -> do confirmSave modified $ liftIO mainQuit
        "about" -> liftIO $ makeAboutDialog >>= widgetShow
        "chgview" -> do put $ state { fsView = (fsView state + 1) `mod` 
                                               (length ?views) }
                        setInterp True
        "addprop" -> do let uri = case node of URI x -> x
                                               _     -> ""
                        confirmString "Add property" uri $ \uri' ->
                            when (uri' /= "") $ do
                                let prop' = URI uri'
                                    props = fsProperties state
                                put $ state { fsProperty = prop',
                                    fsProperties = Set.insert prop' props }
        "resetprop" -> when (fsProperty state /= rdfs_seeAlso) $
                           put $ state { fsProperty = rdfs_seeAlso }
        "changeURI" -> case node of
                           URI uri -> confirmString "New URI" uri $ \uri' ->
                              put $ stateReplaceNode (URI uri) (URI uri') state
                           _       -> unhandledEvent
        "undo" | (graph',rot'):undos <- fsUndo state -> do
                   put state {fsGraph=graph', fsRotation=rot', 
                              fsUndo=undos, fsRedo=(graph,rot):fsRedo state}
                   setInterp True
        "redo" | (graph',rot'):redos <- fsRedo state -> do
                   put state {fsGraph=graph', fsRotation=rot', 
                              fsUndo=(graph,rot):fsUndo state, fsRedo=redos}
                   setInterp True
        _       -> do liftIO $ putStrLn $ "Unhandled action: " ++ action
                      unhandledEvent
  where putGraph g        = do modify $ \s ->
                                   s { fsGraph=g, fsGraphModified=True,
                                       fsUndo=(fsGraph s, fsRotation s):fsUndo s, fsRedo=[]}
                               setInterp True
        putRotation rot   = do modify $ \s -> s { fsRotation=rot }
                               setInterp True
        putMark mk        = do modify $ \state -> state { fsMark=mk }
        delLit n graph = deleteAll n rdfs_label graph

makeActions actionGroup accelGroup = do
    let actionentries = 
            [ ( "new"    , Nothing, stockNew           , Nothing              )
            , ( "open"   , Nothing, stockOpen          , Nothing              )
            , ( "save"   , Nothing, stockSave          , Nothing              )
            , ( "saveas" , Nothing, stockSaveAs        , Just "<Ctl><Shift>S" )
            , ( "revert" , Nothing, stockRevertToSaved , Nothing              )
            , ( "quit"   , Nothing, stockQuit          , Nothing              )
            , ( "about"  , Nothing, stockAbout         , Nothing              )
            , ( "loadURI", Just "_Load node's URI",
                                    stockGoForward     , Just "<Ctl>L"        )
            , ( "undo"   , Nothing, stockUndo          , Just "<Ctl>Z"        )
            , ( "redo"   , Nothing, stockRedo          , Just "<Ctl><Shift>Z" )
            ]
    forM actionentries $ \(name,label',stock,accel) -> do 
        action <- actionNew name label' Nothing (Just stock)
        actionGroupAddActionWithAccel actionGroup action accel
        actionSetAccelGroup action accelGroup

updateActions actionGroup stateRef = do
    state <- readIORef stateRef
    let readable = fsFilePath state /= ""
        modified = fsGraphModified state
        view = fst $ ?views !! (fsView state)

    Just save <- actionGroupGetAction actionGroup "save"
    actionSetSensitive save modified
    Just revert <- actionGroupGetAction actionGroup "revert"
    actionSetSensitive revert (modified && readable)
    Just undo <- actionGroupGetAction actionGroup "undo"
    actionSetSensitive undo (not $ null $ fsUndo state)
    Just redo <- actionGroupGetAction actionGroup "redo"
    actionSetSensitive redo (not $ null $ fsRedo state)
    Just changeView <- actionGroupGetAction actionGroup view
    toggleActionSetActive (castToToggleAction changeView) True
    
updatePropMenu propmenu actionGroup stateRef updateCanvas = do
    state <- readIORef stateRef
    Just addProp <- actionGroupGetAction actionGroup "addprop"
                
    menu <- menuNew
    forM (Set.toAscList $ fsProperties state) $ \prop -> do
        item <- let ?graph = fsGraph state
                 in menuItemNewWithLabel $ getTextOrURI prop
        onActivateLeaf item $ do 
            modifyIORef stateRef $ \state' -> state' {fsProperty=prop}
            updateCanvas False
        menuShellAppend menu item
        widgetShow item
    sep <- separatorMenuItemNew
    menuShellAppend menu sep
    widgetShow sep
    item <- actionCreateMenuItem addProp
    menuShellAppend menu $ castToMenuItem item
    
    menuItemSetSubmenu propmenu menu

makeBindings actionGroup bindings = do
    let bindingentries =
            [ ("noder"  , Just "_New node to right"         , 
               stockMediaForward  , Just "n"              )
            , ("nodel"  , Just "N_ew node to left"          , 
               stockMediaRewind   , Just "<Shift>N"       )
            , ("breakr" , Just "_Break connection to right" , 
               stockGotoLast      , Just "b"              )
            , ("breakl" , Just "B_reak connection to left"  , 
               stockGotoFirst     , Just "<Shift>B"       )
            , ("mark"   , Just "Toggle _mark"               ,
               stockOk            , Just "m"              )
            , ("connr"  , Just "_Connect marked to right"   ,
               stockGoForward     , Just "c"              )
            , ("connl"  , Just "C_onnect marked to left"    ,
               stockGoBack        , Just "<Shift>C"       )
            , ("rmlit"  , Just "Remove _literal text"       ,
               stockStrikethrough , Just "<Alt>BackSpace" )
            , ("addprop", Just "_Add property"              ,
               stockAdd           , Just "<Ctl>P"         )
            , ("changeURI", Just "Change node's _URI"       ,
               stockRefresh       , Just "u"              )
            ]
    forM bindingentries $ \(name,label',stock,accel) -> do 
        action <- actionNew name label' Nothing (Just stock)
        actionGroupAddActionWithAccel actionGroup action accel
        actionSetAccelGroup action bindings

makeMenus actionGroup root propmenu = addAll root menu where
    menu = [m "_File" [a "new", a "open", a "loadURI", sep,
                       a "save", a "saveas", a "revert", sep,
                       a "quit"],
            m "_Edit" [a "undo", a "redo", sep,
                       return propmenu, sep,
                       a "noder", a "nodel", sep,
                       a "breakr", a "breakl", sep,
                       a "mark", a "connr", a "connl", sep, 
                       a "changeURI", a "rmlit"],
            m "_View" (map (a . fst) ?views),
            m "_Help" [a "about"]]
    addAll parent items = mapM_ (menuShellAppend parent) =<< sequence items
    m :: String -> [IO MenuItem] -> IO MenuItem
    m name children = do item <- menuItemNewWithMnemonic name
                         menu' <- menuNew
                         addAll menu' children
                         menuItemSetSubmenu item menu'
                         return item
    sep = liftM castToMenuItem separatorMenuItemNew
    a name = do Just action <- actionGroupGetAction actionGroup name
                item <- actionCreateMenuItem action
                return (castToMenuItem item)

makeToolbarItems actionGroup toolbar = do
    forM_ ["new", "open", "save", "", "undo", "redo"] $ \name -> 
        if name == "" then do 
            item <- separatorToolItemNew
            toolbarInsert toolbar item (-1)
        else do
            Just action <- actionGroupGetAction actionGroup name
            item <- actionCreateToolItem action
            toolbarInsert toolbar (castToToolItem item) (-1)


main :: IO ()
main = do

    uriMaker <- newURIMaker

    -- initial state:

    args <- initGUI

    window <- windowNew
    style <- widgetGetStyle window

    bgColor <- styleGetBackground style StateSelected
    blurBgColor <- styleGetBackground style StateActive
    focusColor <- styleGetBase style StateSelected
    blurColor <- styleGetBase style StateActive
    textColor <- styleGetText style StateSelected
    blurTextColor <- styleGetText style StateActive
    
    canvasBgColor <- styleGetBackground style StateNormal

    let alpha x (Color r g b a) = Color r g b (x*a)

    let ?vs = ViewSettings { hiddenProps=[rdfs_label], maxCenter=3 }
        ?uriMaker = uriMaker in let
        ?views = [("Wheel view", vanishingView 20 30 
                       (alpha 0.7 $ fromGtkColor bgColor)
                           (alpha 0.7 $ fromGtkColor blurBgColor)
                       (fromGtkColor focusColor) (fromGtkColor blurColor)
                       (fromGtkColor textColor)  (fromGtkColor blurTextColor)),
                  ("Presentation view", presentationView)] in do

    let view s = snd (?views !! fsView s) s

    stateRef <- case args of 
        [] -> do 
            (g, rot) <- newGraph
            newIORef $ newState g rot "" False
        xs -> do
            let f x | Data.List.isPrefixOf "http:" x = return x
                    | otherwise = canonicalizePath x
            fileName:fileNames <- mapM f xs
            g' <- loadGraph fileName
            gs <- mapM loadGraph fileNames
            let graph = foldl mergeGraphs g' gs
            newIORef $ newState graph (findStartRotation graph) fileName False

    -- start:

    makeWindow window canvasBgColor view stateRef
    widgetShowAll window

    mainGUI

makeWindow window canvasBgColor view stateRef = do

    -- main window:

    let ?pw = window in mdo
    logo <- getDataFileName "data/icon16.png"
    Control.Exception.catch (windowSetIconFromFile window logo)
          (\e -> putStr ("Opening "++logo++" failed: ") >> print e)
    windowSetTitle window "Fenfire"
    windowSetDefaultSize window 800 550

    -- textview for editing:
    
    textView <- textViewNew
    textViewSetAcceptsTab textView False
    textViewSetWrapMode textView WrapWordChar

    -- this needs to be called whenever the node or its text changes:
    let stateChanged _ (FenState { fsRotation=Rotation n _, fsGraph=g }) = do
            buf <- textBufferNew Nothing
            textBufferSetText buf (let ?graph=g in maybe "" id $ getText n)
            afterBufferChanged buf $ do 
                start <- textBufferGetStartIter buf
                end   <- textBufferGetEndIter buf
                text  <- textBufferGetText buf start end True
                FenState { fsGraph = g', fsRotation = Rotation n' r' } 
                    <- readIORef stateRef
                let g'' = setText n text g' -- buf corresponds to n, not to n'

                modifyIORef stateRef $ \s -> 
                    s { fsGraph=g'', fsRotation = Rotation n' r',
                        fsGraphModified=True, fsRedo=[],
                        fsUndo=(fsGraph s, fsRotation s):(fsUndo s) }
                updateActions actionGroup stateRef
                updateCanvas True

            textViewSetBuffer textView buf
            updatePropMenu propmenu actionGroup stateRef updateCanvas
            updateActions actionGroup stateRef

    -- canvas for view:
    
    (canvas, updateCanvas, canvasAction) <- 
        vobCanvas stateRef view handleEvent handleAction
                  stateChanged (fromGtkColor canvasBgColor) 0.5

    onFocusIn canvas $ \_event -> do 
        modifyIORef stateRef $ \s -> s { fsHasFocus = True }
        forM_ bindingActions $ actionConnectAccelerator
        updateCanvas True
        return True
    onFocusOut canvas $ \_event -> do 
        modifyIORef stateRef $ \s -> s { fsHasFocus = False }
        forM_ bindingActions $ actionDisconnectAccelerator
        updateCanvas True
        return True

    -- action widgets:

    accelGroup <- accelGroupNew
    windowAddAccelGroup window accelGroup
    -- bindings are active only when the canvas has the focus:
    bindings <- accelGroupNew
    windowAddAccelGroup window bindings
    -- fake bindings aren't used
    fake <- accelGroupNew

    actionGroup <- actionGroupNew "main"
    bindingGroup <- actionGroupNew "bindings"

    makeActions actionGroup accelGroup 
    makeBindings bindingGroup bindings
    makeBindings actionGroup fake

    actions <- actionGroupListActions actionGroup
    bindingActions <- actionGroupListActions bindingGroup

    forM_ (actions ++ bindingActions) $ \action -> do
        name <- actionGetName action
        onActionActivate action $ canvasAction name >> return ()
        
    viewActs <- forM (zip [0..] ?views) $ \(index, (name, _view)) -> do
        action <- radioActionNew name name Nothing Nothing index
        actionGroupAddAction actionGroup action
        onActionActivate action $ do
            i <- radioActionGetCurrentValue action
            state <- readIORef stateRef
            when (i /= fsView state) $ do
                writeIORef stateRef $ state { fsView = i }
                updateCanvas True
        return action
        
    forM_ (tail viewActs) $ \x -> radioActionSetGroup x (head viewActs)
    toggleActionSetActive (toToggleAction $ head viewActs) True

    -- user interface widgets:

    menubar <- menuBarNew
    propmenu <- menuItemNewWithMnemonic "Set _property"
    makeMenus actionGroup menubar propmenu

    toolbar <- toolbarNew
    makeToolbarItems actionGroup toolbar

    -- layout:

    canvasFrame <- frameNew
    set canvasFrame [ containerChild := canvas
                      , frameShadowType := ShadowIn 
                      ]

    textViewFrame <- frameNew
    set textViewFrame [ containerChild := textView
                      , frameShadowType := ShadowIn 
                      ]

    paned <- vPanedNew
    panedAdd1 paned canvasFrame
    panedAdd2 paned textViewFrame

    vBox <- vBoxNew False 0
    boxPackStart vBox menubar PackNatural 0
    boxPackStart vBox toolbar PackNatural 0
    boxPackStart vBox paned PackGrow 0
    containerSetFocusChain vBox [toWidget paned]
    
    set paned [ panedPosition := 380, panedChildResize textViewFrame := False ]

    set window [ containerChild := vBox ]

    -- start:

    startState <- readIORef stateRef
    stateChanged (startState { fsProperties = Set.empty }) startState
    
    widgetGrabFocus canvas

    onDelete window $ \_event -> canvasAction "quit"


makeAboutDialog :: (?pw :: Window) => IO AboutDialog
makeAboutDialog = do
    dialog <- aboutDialogNew
    logoFilename <- getDataFileName "data/logo.svg"
    pixbuf <- Control.Exception.catch (pixbufNewFromFile logoFilename)
                  (\e -> return $ Left (undefined, show e))
    logo <- case pixbuf of Left (_,msg)  -> do 
                               putStr ("Opening "++logoFilename++" failed: ")
                               putStrLn msg
                               return Nothing
                           Right pixbuf' -> return . Just =<< 
                               pixbufScaleSimple pixbuf'
                                   200 (floor (200*(1.40::Double))) 
                                   InterpHyper 
    set dialog [ aboutDialogName := "Fenfire" 
               , aboutDialogVersion := "alpha version"
               , aboutDialogCopyright := "Licensed under GNU GPL v2 or later"
               , aboutDialogComments := 
                     "An application for notetaking and RDF graph browsing."
               , aboutDialogLogo := logo
               , aboutDialogWebsite := "http://fenfire.org"
               , aboutDialogAuthors := ["Benja Fallenstein", "Tuukka Hastrup"]
               , windowTransientFor := ?pw
               ]
    onResponse dialog $ \_response -> widgetHide dialog
    return dialog

makeDialog :: (?pw :: Window) => String -> [(String, ResponseId)] -> 
                                 ResponseId -> IO Dialog
makeDialog title buttons preset = do
    dialog <- dialogNew
    set dialog [ windowTitle := title
               , windowTransientFor := ?pw
               , windowModal := True
               , windowDestroyWithParent := True
               , dialogHasSeparator := False
               ]
    mapM_ (uncurry $ dialogAddButton dialog) buttons
    dialogSetDefaultResponse dialog preset
    return dialog

makeConfirmUnsavedDialog :: (?pw :: Window) => IO Dialog
makeConfirmUnsavedDialog = do 
    makeDialog "Confirm unsaved changes" 
        [("_Discard changes", ResponseClose),
         (stockCancel, ResponseCancel),
         (stockSave, ResponseAccept)]
        ResponseAccept

makeConfirmRevertDialog :: (?pw :: Window) => IO Dialog
makeConfirmRevertDialog = do
    makeDialog "Confirm revert"
        [(stockCancel, ResponseCancel),
         (stockRevertToSaved,ResponseClose)]
        ResponseCancel
